<!DOCTYPE html>
<html lang="ru">
<head>
    <!-- –ú–µ—Ç–∞-—Ç–µ–≥–∏ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ SEO -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–µ —à–∞—Ö–º–∞—Ç—ã —Å –ü–†–ê–í–ò–õ–ê–ú–ò —Ö–æ–¥–∞, –†–ê–ë–û–¢–ê–Æ–©–ò–ú –¢–ê–ô–ú–ï–†–û–ú –∏ –£–ú–ù–´–ú –ò–ò">
    <title>–®–∞—Ö–º–∞—Ç—ã.Pro</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* –í—Å–µ —Å—Ç–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã - —Å—É–ø–µ—Ä—Å–∫–∏–π –¥–∏–∑–∞–π–Ω */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #fff; min-height: 100vh; overflow-x: hidden;
        }
        header { position: fixed; top: 0; width: 100%; background: rgba(0,0,0,0.95); 
            backdrop-filter: blur(15px); z-index: 1000; padding: 1rem 0; }
        nav { display: flex; justify-content: space-between; align-items: center;
            max-width: 1400px; margin: 0 auto; padding: 0 2rem; }
        .logo { font-size: 2rem; font-weight: 700; background: linear-gradient(45deg, #ffd700, #ffed4a);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 30px rgba(255,215,0,0.6); }
        .hero { height: 100vh; display: flex; flex-direction: column; justify-content: center; 
            align-items: center; text-align: center; padding: 0 2rem; }
        .hero h1 { font-size: clamp(4rem, 10vw, 7rem); margin-bottom: 1.5rem;
            background: linear-gradient(45deg, #fff, #ffd700); -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; animation: glow 2s ease-in-out infinite alternate; }
        @keyframes glow { from { filter: drop-shadow(0 0 20px #ffd700); } to { filter: drop-shadow(0 0 30px #ffd700); } }
        
        .settings-panel { background: rgba(255,255,255,0.1); backdrop-filter: blur(20px); border-radius: 25px; 
            padding: 2rem; margin: 2rem auto; max-width: 900px; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 25px 50px rgba(0,0,0,0.5); }
        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 2rem; }
        .setting-group label { display: block; margin-bottom: 0.8rem; font-weight: 600; color: #ffd700; }
        select, button { padding: 0.8rem 1.5rem; background: rgba(255,255,255,0.2); color: #fff; 
            border: 2px solid rgba(255,215,0,0.5); border-radius: 15px; font-family: inherit; 
            font-weight: 600; cursor: pointer; transition: all 0.3s ease; width: 100%; }
        select:hover, button:hover { background: rgba(255,215,0,0.8); color: #1e3c72;
            transform: translateY(-3px); box-shadow: 0 10px 25px rgba(255,215,0,0.4); }
        
        .chess-section { padding: 120px 2rem 50px; max-width: 1400px; margin: 0 auto; text-align: center; }
        #chessboard { width: 600px; height: 600px; display: block; margin: 2rem auto;
            border-radius: 25px; box-shadow: 0 30px 80px rgba(0,0,0,0.7);
            background: linear-gradient(145deg, #8B4513, #A0522D); cursor: pointer; }
        .timers { display: flex; justify-content: center; gap: 3rem; margin: 2rem 0; font-size: 1.8rem; font-weight: 700; }
        .timer { padding: 1rem 2rem; border-radius: 20px; min-width: 150px; text-align: center; }
        .timer.white { background: rgba(255,255,255,0.3); }
        .timer.black { background: rgba(0,0,0,0.6); color: #ffd700; }
        .time-low { animation: blink 0.5s infinite; color: #ff4444; }
        @keyframes blink { 0%,50% { opacity: 1; } 51%,100% { opacity: 0.3; } }
        .game-controls { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin: 2rem 0; }
        .btn { padding: 1rem 2rem; background: linear-gradient(45deg, #ffd700, #ffed4a); color: #1e3c72; 
            border: none; border-radius: 25px; font-weight: 700; cursor: pointer; transition: all 0.3s; font-family: inherit; }
        .btn:hover { transform: translateY(-5px); box-shadow: 0 15px 35px rgba(255,215,0,0.6); }
        #gameStatus { font-size: 2rem; font-weight: 700; margin: 2rem 0; min-height: 2.5rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        @media (max-width: 768px) { #chessboard { width: 90vw; height: 90vw; max-width: 500px; max-height: 500px; }
            .timers { gap: 1rem; font-size: 1.2rem; } .settings-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <header>
        <nav><div class="logo">–®–∞—Ö–º–∞—Ç—ã.Pro</div></nav>
    </header>

    <section class="hero">
        <h1>–ù–∞—Å—Ç–æ—è—â–∏–µ –®–∞—Ö–º–∞—Ç—ã!</h1>
        <p>–≤—Å—ë –∫—Ä–æ–º–µ —Ä–∞–∫–∏—Ä–æ–≤–∞–∫</p>
    </section>

    <div class="settings-panel">
        <h2 style="text-align: center; margin-bottom: 2rem; color: #ffd700;">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
        <div class="settings-grid">
            <div class="setting-group">
                <label>üéÆ –†–µ–∂–∏–º:</label>
                <select id="gameMode"><option value="vsAI">vs –ò–ò</option><option value="vsPlayer">2 –ò–≥—Ä–æ–∫–∞</option></select>
            </div>
            <div class="setting-group">
                <label>‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:</label>
                <select id="aiDifficulty"><option value="2">–°—Ä–µ–¥–Ω–µ</option><option value="3">–°–ª–æ–∂–Ω–æ</option><option value="1">–õ–µ–≥–∫–æ</option></select>
            </div>
            <div class="setting-group">
                <label>üëë –°—Ç–æ—Ä–æ–Ω–∞:</label>
                <select id="playerSide"><option value="white">–ë–µ–ª—ã–µ</option><option value="black">–ß–µ—Ä–Ω—ã–µ</option></select>
            </div>
            <div class="setting-group">
                <label>‚è±Ô∏è –í—Ä–µ–º—è:</label>
                <select id="timeControl"><option value="600">10 –º–∏–Ω</option><option value="unlimited">–ë–µ–∑ –ª–∏–º–∏—Ç–∞</option></select>
            </div>
        </div>
        <button id="applySettings" class="btn" style="width: 100%; font-size: 1.2rem;">üöÄ –ù–ê–ß–ê–¢–¨!</button>
    </div>

    <section class="chess-section">
        <h2 style="font-size: 3.5rem; margin-bottom: 2rem;">–ò–≥—Ä–∞–π –ø–æ –ü—Ä–∞–≤–∏–ª–∞–º!</h2>
        <div class="timers">
            <div id="whiteTimer" class="timer white">10:00</div>
            <div id="blackTimer" class="timer black">10:00</div>
        </div>
        <canvas id="chessboard" width="600" height="600"></canvas>
        <div class="game-controls">
            <button id="newGame" class="btn">üîÑ –ù–æ–≤–∞—è</button>
            <button id="flipBoard" class="btn">‚Ü∫ –ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
        </div>
        <div id="gameStatus">–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∏–≥—Ä—É –∏ –Ω–∞—á–Ω–∏—Ç–µ!</div>
    </section>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        const canvas = document.getElementById('chessboard');
        const ctx = canvas.getContext('2d');
        let board = [], currentPlayer = 'white', selectedPiece = null, gameOver = false;
        let gameMode = 'vsAI', aiDifficulty = 2, playerSide = 'white';
        
        // ‚úÖ –¢–ê–ô–ú–ï–†–´
        let whiteTime = 600, blackTime = 600, timeControl = '600';
        let whiteTimerInterval, blackTimerInterval, currentTimerInterval;
        let gameStarted = false;

        // ‚úÖ –ß–ï–†–ù–´–ï –§–ò–ì–£–†–´ - –¢–ï–ú–ù–´–ï –¶–í–ï–¢–ê –° –¢–ï–ù–Ø–ú–ò
        const pieceSymbols = {
            // –ë–µ–ª—ã–µ —Ñ–∏–≥—É—Ä—ã - —Å–≤–µ—Ç–ª—ã–µ –∫–æ–Ω—Ç—É—Ä—ã
            'P': '‚ôô', 'R': '‚ôñ', 'N': '‚ôò', 'B': '‚ôó', 'Q': '‚ôï', 'K': '‚ôî',
            // –ß–ï–†–ù–´–ï —Ñ–∏–≥—É—Ä—ã - –ì–õ–£–ë–û–ö–ò–ï –¢–ï–ú–ù–´–ï –¶–í–ï–¢–ê
            'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö'
        };

        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —à–∞—Ö–º–∞—Ç–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞
        function initBoard() {
            board = [
                ['r','n','b','q','k','b','n','r'], // –ß–µ—Ä–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã
                ['p','p','p','p','p','p','p','p'], // –ß–µ—Ä–Ω—ã–µ –ø–µ—à–∫–∏
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['P','P','P','P','P','P','P','P'], // –ë–µ–ª—ã–µ –ø–µ—à–∫–∏
                ['R','N','B','Q','K','B','N','R']  // –ë–µ–ª—ã–µ —Ñ–∏–≥—É—Ä—ã
            ];
            currentPlayer = playerSide;
            selectedPiece = null; 
            gameOver = false;
            gameStarted = false;
            whiteTime = parseInt(timeControl);
            blackTime = parseInt(timeControl);
            updateTimers();
        }

        // ‚úÖ –†–ê–ë–û–¢–ê–Æ–©–ò–ô –¢–ê–ô–ú–ï–†
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimers() {
            document.getElementById('whiteTimer').textContent = formatTime(whiteTime);
            document.getElementById('blackTimer').textContent = formatTime(blackTime);
            
            // –ú–∏–≥–∞—é—â–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏ –Ω–∏–∑–∫–æ–º –≤—Ä–µ–º–µ–Ω–∏
            if (whiteTime <= 30 && currentPlayer === 'white') {
                document.getElementById('whiteTimer').classList.add('time-low');
            } else {
                document.getElementById('whiteTimer').classList.remove('time-low');
            }
            if (blackTime <= 30 && currentPlayer === 'black') {
                document.getElementById('blackTimer').classList.add('time-low');
            } else {
                document.getElementById('blackTimer').classList.remove('time-low');
            }
        }

        function startTimer() {
            if (timeControl === 'unlimited') return;
            
            clearInterval(currentTimerInterval);
            if (currentPlayer === 'white') {
                currentTimerInterval = setInterval(() => {
                    whiteTime--;
                    updateTimers();
                    if (whiteTime <= 0) {
                        gameOver = true;
                        updateStatus('‚è∞ –í–†–ï–ú–Ø –ë–ï–õ–´–• –ö–û–ù–ß–ò–õ–û–°–¨! –ß–ï–†–ù–´–ï –ü–û–ë–ï–î–ò–õ–ò!');
                        clearInterval(currentTimerInterval);
                    }
                }, 1000);
            } else {
                currentTimerInterval = setInterval(() => {
                    blackTime--;
                    updateTimers();
                    if (blackTime <= 0) {
                        gameOver = true;
                        updateStatus('‚è∞ –í–†–ï–ú–Ø –ß–ï–†–ù–´–• –ö–û–ù–ß–ò–õ–û–°–¨! –ë–ï–õ–´–ï –ü–û–ë–ï–î–ò–õ–ò!');
                        clearInterval(currentTimerInterval);
                    }
                }, 1000);
            }
        }

        // ‚úÖ –ü–û–õ–ù–´–ï –ü–†–ê–í–ò–õ–ê –•–û–î–ê –ö–ê–ñ–î–û–ô –§–ò–ì–£–†–´
        function getLegalMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            const moves = [];
            const isWhite = piece === piece.toUpperCase();
            
            switch(piece.toUpperCase()) {
                case 'P': // –ü–ï–®–ö–ê
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 6 : 1;
                    
                    // –®–∞–≥ –≤–ø–µ—Ä–µ–¥
                    if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {
                        moves.push({row: row + direction, col});
                        // –î–≤–æ–π–Ω–æ–π —à–∞–≥
                        if (row === startRow && !board[row + 2 * direction][col]) {
                            moves.push({row: row + 2 * direction, col});
                        }
                    }
                    // –í–∑—è—Ç–∏–µ
                    [-1, 1].forEach(dc => {
                        const nr = row + direction, nc = col + dc;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                            const target = board[nr][nc];
                            if (target && (target === target.toUpperCase()) !== isWhite) {
                                moves.push({row: nr, col: nc});
                            }
                        }
                    });
                    break;
                    
                case 'R': // –õ–ê–î–¨–Ø
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            const nr = row + i * dr, nc = col + i * dc;
                            if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                            if (!board[nr][nc]) moves.push({row: nr, col: nc});
                            else {
                                if ((board[nr][nc] === board[nr][nc].toUpperCase()) !== isWhite) {
                                    moves.push({row: nr, col: nc});
                                }
                                break;
                            }
                        }
                    });
                    break;
                    
                case 'N': // –ö–û–ù–¨
                    const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                    knightMoves.forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                            const target = board[nr][nc];
                            if (!target || (target === target.toUpperCase()) !== isWhite) {
                                moves.push({row: nr, col: nc});
                            }
                        }
                    });
                    break;
                    
                case 'B': // –°–õ–û–ù
                    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            const nr = row + i * dr, nc = col + i * dc;
                            if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                            if (!board[nr][nc]) moves.push({row: nr, col: nc});
                            else {
                                if ((board[nr][nc] === board[nr][nc].toUpperCase()) !== isWhite) {
                                    moves.push({row: nr, col: nc});
                                }
                                break;
                            }
                        }
                    });
                    break;
                    
                case 'Q': // –§–ï–†–ó–¨
                    getLegalMovesForRook(row, col, moves, isWhite);
                    getLegalMovesForBishop(row, col, moves, isWhite);
                    break;
                    
                case 'K': // –ö–û–†–û–õ–¨
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                const target = board[nr][nc];
                                if (!target || (target === target.toUpperCase()) !== isWhite) {
                                    moves.push({row: nr, col: nc});
                                }
                            }
                        }
                    }
                    break;
            }
            return moves;
        }

        function getLegalMovesForRook(row, col, moves, isWhite) {
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const nr = row + i * dr, nc = col + i * dc;
                    if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                    if (!board[nr][nc]) moves.push({row: nr, col: nc});
                    else {
                        if ((board[nr][nc] === board[nr][nc].toUpperCase()) !== isWhite) moves.push({row: nr, col: nc});
                        break;
                    }
                }
            });
        }

        function getLegalMovesForBishop(row, col, moves, isWhite) {
            [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                for (let i = 1; i < 8; i++) {
                    const nr = row + i * dr, nc = col + i * dc;
                    if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                    if (!board[nr][nc]) moves.push({row: nr, col: nc});
                    else {
                        if ((board[nr][nc] === board[nr][nc].toUpperCase()) !== isWhite) moves.push({row: nr, col: nc});
                        break;
                    }
                }
            });
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ö–æ–¥–∞
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;
            const moves = getLegalMoves(fromRow, fromCol);
            return moves.some(move => move.row === toRow && move.col === toCol);
        }

        // ‚úÖ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–¢–†–ò–°–û–í–ö–ê –° –¢–ï–ú–ù–´–ú–ò –ß–ï–†–ù–´–ú–ò –§–ò–ì–£–†–ê–ú–ò
        function drawBoard() {
            const cellSize = 600 / 8;
            
            // –ö–ª–µ—Ç–∫–∏ —à–∞—Ö–º–∞—Ç–Ω–æ–π –¥–æ—Å–∫–∏
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    ctx.fillStyle = (row + col) % 2 === 0 ? '#EEECD8' : '#B58863';
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ñ–∏–≥—É—Ä—ã
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 30;
                        ctx.fillStyle = 'rgba(255,215,0,0.6)';
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä —Å –£–°–ò–õ–ï–ù–ù–´–ú–ò –¢–ï–ú–ù–´–ú–ò –ß–ï–†–ù–´–ú–ò
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && pieceSymbols[piece]) {
                        ctx.save();
                        
                        // –ì–õ–£–ëOK–ò–ï –¢–ï–ù–ò –î–õ–Ø –ß–ï–†–ù–´–• –§–ò–ì–£–†
                        ctx.shadowColor = piece === piece.toLowerCase() ? '#000000' : 'rgba(0,0,0,0.6)';
                        ctx.shadowBlur = piece === piece.toLowerCase() ? 25 : 15; 
                        ctx.shadowOffsetY = 10;
                        
                        ctx.font = 'bold 64px serif';
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle';
                        
                        ctx.fillText(pieceSymbols[piece], 
                                   col * cellSize + cellSize/2, 
                                   row * cellSize + cellSize/2);
                        ctx.restore();
                    }
                }
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤
        canvas.addEventListener('click', (e) => {
            if (gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / (600/8));
            const row = Math.floor(y / (600/8));
            const piece = board[row][col];
            
            if (!selectedPiece) {
                if (piece && isPlayerPiece(piece, row, col)) {
                    selectedPiece = {row, col};
                    drawBoard();
                }
            } else {
                if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    gameStarted = true;
                    if (gameMode === 'vsAI' && !gameOver && currentPlayer !== playerSide) {
                        setTimeout(aiMove, 500 + Math.random() * 500);
                    }
                }
                selectedPiece = null;
                drawBoard();
            }
        });

        function isPlayerPiece(piece, row, col) {
            if (!piece) return false;
            const isWhitePiece = piece === piece.toUpperCase();
            if (gameMode === 'vsPlayer') return isWhitePiece === (currentPlayer === 'white');
            return isWhitePiece === (playerSide === 'white');
        }

        // ‚úÖ –£–õ–£–ß–®–ï–ù–ù–´–ô –ò–ò –° –ö–û–ú–ë–ò–ù–ê–¶–ò–Ø–ú–ò
        function aiMove() {
            if (gameOver || currentPlayer !== (playerSide === 'white' ? 'black' : 'white')) return;
            
            let bestMove = null;
            let bestScore = aiDifficulty === 3 ? -Infinity : -100;
            
            // –ò—â–µ–º –≤—ã–∏–≥—Ä—ã—à–Ω—ã–µ —Ö–æ–¥—ã –∏ –∑–∞—â–∏—Ç—É
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece === piece.toLowerCase()) {
                        const moves = getLegalMoves(row, col);
                        for (let move of moves) {
                            const temp = board[move.row][move.col];
                            board[move.row][move.col] = piece; 
                            board[row][col] = null;
                            
                            let score = evaluateBoard();
                            
                            // ‚úÖ –ë–û–ù–£–°–´ –ó–ê –ö–û–ú–ë–ò–ù–ê–¶–ò–ò
                            // –ê—Ç–∞–∫–∞ —Ñ–µ—Ä–∑—è
                            if (piece === 'q') score += 50;
                            // –ê—Ç–∞–∫–∞ –ª–∞–¥—å–∏
                            if (piece === 'r') score += 30;
                            // –¶–µ–Ω—Ç—Ä –¥–æ—Å–∫–∏
                            if (move.row >= 3 && move.row <= 4 && move.col >= 3 && move.col <= 4) score += 20;
                            // –í–∑—è—Ç–∏–µ —Ñ–∏–≥—É—Ä
                            if (temp && temp === temp.toUpperCase()) {
                                score += getPieceValue(temp) * 2;
                            }
                            
                            board[row][col] = piece; 
                            board[move.row][move.col] = temp;
                            
                            if (score > bestScore || !bestMove) {
                                bestScore = score;
                                bestMove = {fromRow: row, fromCol: col, toRow: move.row, toCol: move.col};
                            }
                        }
                    }
                }
            }
            
            if (bestMove) {
                setTimeout(() => {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                }, 300 + Math.random() * 700);
            }
        }

        function getPieceValue(piece) {
            const values = {'P':1,'N':3,'B':3,'R':5,'Q':9,'K':1000};
            return values[piece.toUpperCase()];
        }

        function evaluateBoard() {
            const values = {'P':1,'N':3,'B':3,'R':5,'Q':9,'K':1000};
            let score = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c]; 
                    if (p) score += (p === p.toUpperCase() ? values[p.toUpperCase()] : -values[p.toUpperCase()]);
                }
            }
            return score;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // ‚úÖ –ü–ê–£–ó–ê –¢–ê–ô–ú–ï–†–ê –ü–†–ò –°–ú–ï–ù–ï –•–û–î–ê
            clearInterval(currentTimerInterval);
            startTimer();
            
            checkGameOver();
            updateStatus(`${currentPlayer.toUpperCase()} —Ö–æ–¥—è—Ç!`);
        }

        function checkGameOver() {
            const hasWhiteKing = board.flat().some(p => p === 'K');
            const hasBlackKing = board.flat().some(p => p === 'k');
            if (!hasWhiteKing) { 
                gameOver = true; 
                clearInterval(currentTimerInterval);
                updateStatus('‚úÖ –ß–ï–†–ù–´–ï –ü–û–ë–ï–î–ò–õ–ò!'); 
            }
            else if (!hasBlackKing) { 
                gameOver = true;
                clearInterval(currentTimerInterval);
                updateStatus('‚úÖ –ë–ï–õ–´–ï –ü–û–ë–ï–î–ò–õ–ò!'); 
            }
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        function updateStatus(msg) { 
            document.getElementById('gameStatus').textContent = msg; 
        }
        
        document.getElementById('applySettings').onclick = () => {
            gameMode = document.getElementById('gameMode').value;
            aiDifficulty = parseInt(document.getElementById('aiDifficulty').value);
            playerSide = document.getElementById('playerSide').value;
            timeControl = document.getElementById('timeControl').value;
            initGame();
        };

        function initGame() {
            initBoard();
            drawBoard();
            updateStatus(`${playerSide.toUpperCase()} –Ω–∞—á–∏–Ω–∞—é—Ç!`);
            gameStarted = false;
        }

        document.getElementById('newGame').onclick = initGame;
        document.getElementById('flipBoard').onclick = () => {
            board.reverse();
            for (let row of board) row.reverse();
            drawBoard();
        };

        // –°—Ç–∞—Ä—Ç
        initBoard();
        drawBoard();
    </script>
</body>
</html>

